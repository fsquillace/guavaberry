package org.guavaberry.collections;

import org.guavaberry.function.NullaryOperator;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

/**
 * This is the Java implementation of the
 * <a href="https://docs.python.org/3.6/library/collections.html#collections.defaultdict">Python defaultdict</a>.
 *
 * {@link DefaultHashMap} is a subclass of {@link HashMap} that overrides
 * only the method {@link HashMap#get(Object)}. This class accepts as argument
 * an instance factory. If a certain key is missing in the map,
 * the class produces a default instance and returns it as a value.
 *
 * <p>The remaining functionality is the same as for the {@link HashMap} class
 * and is not documented here.
 *
 * <p>An example on how to use {@link DefaultHashMap}:
 * <pre>
 * {@code
 *     DefaultHashMap<Integer, List<String>> map = new DefaultHashMap(() -> new ArrayList<>());
 *     map.get(11).add("first");
 * }
 * </pre>
 *
 * @author  Filippo Squillace
 *
 * @param <K> the type of keys maintained by this map
 * @param <V> the type of mapped values
 *
 * @see     HashMap
 * @since   0.1.0
 */
public class DefaultHashMap<K, V> extends HashMap<K, V> {
    /**
     * The factory instance invoked during a missing entry.
     */
    private final NullaryOperator<V> operator;

    /**
     * Constructs an empty <tt>HashMap</tt> with the specified initial
     * capacity and load factor.
     *
     * @param  operator the instance factory
     * @param  initialCapacity the initial capacity
     * @param  loadFactor      the load factor
     * @throws IllegalArgumentException if the initial capacity is negative
     *         or the load factor is nonpositive
     */
    public DefaultHashMap(final NullaryOperator<V> operator, final int initialCapacity,
                          final float loadFactor) {
        super(initialCapacity, loadFactor);
        Objects.requireNonNull(operator);
        this.operator = operator;
    }

    /**
     * Constructs an empty <tt>HashMap</tt> with the specified initial
     * capacity and the default load factor (0.75).
     *
     * @param  operator the instance factory
     * @param  initialCapacity the initial capacity.
     * @throws IllegalArgumentException if the initial capacity is negative.
     */
    public DefaultHashMap(final NullaryOperator<V> operator,
                          final int initialCapacity) {
        super(initialCapacity);
        Objects.requireNonNull(operator);
        this.operator = operator;
    }

    /**
     * Constructs an empty <tt>HashMap</tt> with the default initial capacity
     * (16) and the default load factor (0.75).
     *
     * @param  operator the instance factory
     */
    public DefaultHashMap(final NullaryOperator<V> operator) {
        super();
        Objects.requireNonNull(operator);
        this.operator = operator;
    }

    /**
     * Constructs a new <tt>HashMap</tt> with the same mappings as the
     * specified <tt>Map</tt>.  The <tt>HashMap</tt> is created with
     * default load factor (0.75) and an initial capacity sufficient to
     * hold the mappings in the specified <tt>Map</tt>.
     *
     * @param  operator the instance factory
     * @param  otherMap the map whose mappings are to be placed in this map
     * @throws  NullPointerException if the specified map is null
     */
    public DefaultHashMap(final NullaryOperator<V> operator,
                          final Map<? extends K, ? extends V> otherMap) {
        super(otherMap);
        Objects.requireNonNull(operator);
        this.operator = operator;
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or a default value generated by the instance factory if this map
     * contains no mapping for the key.
     *
     * <p>By calling this method multiple times passing the same key, the method will return
     * the same value (idempotent).
     *
     * @param key the key for the lookup
     * @return the mapped value or a default default if key does not exist in the map
     *
     * @see #put(Object, Object)
     */
    @Override
    public final V get(final Object key) {
        V value = super.get(key);
        if (value == null) {
            value = operator.op();
        }
        // The following guarantees idempotent call to get method
        put((K) key, value);
        return value;
    }
}
